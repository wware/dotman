#!/usr/bin/env python3
"""
Dotfiles manager - Auto-discovery based dotfiles and local modifications manager.

This tool automatically discovers what needs to be symlinked vs overlaid by:
1. Scanning the private repo directory structure
2. Checking .gitignore to determine if files should be symlinked (ignored) or overlaid (tracked)
3. Handling all git skip-worktree operations transparently
"""

import os
import sys
import subprocess
import shutil
from pathlib import Path
import argparse
from typing import List, Tuple, Set
import fnmatch

# Note: For complete documentation, see the README.md file


class DotmanLongHelpFormatter(argparse.RawDescriptionHelpFormatter):
    """Custom help formatter that refers to README file for --help."""

    def format_help(self):
        # Get the standard help text first
        help_text = super().format_help()

        # Add reference to README
        return help_text + "\nFor complete documentation, see https://github.com/wware/dotman.\n"


def load_config() -> Tuple[Path, Path]:
    """
    Load source and destination paths from (in order of precedence):
    1. .dotmanrc file in current directory
    2. Environment variables DOTMAN_SRC and DOTMAN_DST
    3. .env file in current directory

    Returns:
        (source_path, destination_path) tuple

    Raises:
        RuntimeError: If configuration cannot be loaded
    """
    # Try .dotmanrc first
    dotmanrc = Path.cwd() / ".dotmanrc"
    if dotmanrc.exists():
        config = {}
        with open(dotmanrc) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    config[key.strip()] = value.strip().strip('"').strip("'")

        src = config.get('SRC')
        dst = config.get('DST')
        if src and dst:
            return Path(src).expanduser(), Path(dst).expanduser()

    # Try environment variables
    src = os.environ.get('DOTMAN_SRC')
    dst = os.environ.get('DOTMAN_DST')
    if src and dst:
        return Path(src).expanduser(), Path(dst).expanduser()

    # Try .env file
    dotenv = Path.cwd() / ".env"
    if dotenv.exists():
        config = {}
        with open(dotenv) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    config[key.strip()] = value.strip().strip('"').strip("'")

        src = config.get('DOTMAN_SRC')
        dst = config.get('DOTMAN_DST')
        if src and dst:
            return Path(src).expanduser(), Path(dst).expanduser()

    # Nothing worked - raise error with helpful message
    raise RuntimeError(
        "Could not load dotman configuration. Please provide configuration via:\n"
        "  1. .dotmanrc file with: SRC=/path/to/source\n"
        "                          DST=/path/to/dest\n"
        "  2. Environment variables: DOTMAN_SRC and DOTMAN_DST\n"
        "  3. .env file with: DOTMAN_SRC=/path/to/source\n"
        "                     DOTMAN_DST=/path/to/dest"
    )


# Configuration will be loaded when needed
PRIVATE_REPO = None
WORKING_DIR = None
BACKUPS_DIR = None

class GitIgnoreChecker:
    """Helper to check if files match .gitignore patterns."""

    def __init__(self, gitignore_path: Path):
        self.patterns = []
        if gitignore_path.exists():
            with open(gitignore_path) as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        self.patterns.append(line)

    def is_ignored(self, file_path: str) -> bool:
        """Check if a file path matches any .gitignore pattern."""
        for pattern in self.patterns:
            # Direct pattern match
            if fnmatch.fnmatch(file_path, pattern):
                return True

            # Check if file is under an ignored directory
            if '/' in file_path:
                parts = file_path.split('/')
                for i in range(len(parts)):
                    # Check if any parent directory matches the pattern
                    parent_path = '/'.join(parts[:i+1])
                    if fnmatch.fnmatch(parent_path, pattern):
                        return True
                    # Check directory pattern without trailing slash
                    if fnmatch.fnmatch(parent_path + '/', pattern):
                        return True

            # Check if pattern matches just the filename
            filename = file_path.split('/')[-1]
            if fnmatch.fnmatch(filename, pattern):
                return True

        return False

class DotfilesManager:
    def __init__(self):
        try:
            self.private_repo, self.working_dir = load_config()
            self.backups_dir = self.private_repo / "backups"
        except RuntimeError as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
        self.gitignore_checker = GitIgnoreChecker(self.working_dir / ".gitignore")

    def discover_files(self) -> Tuple[List[Tuple[Path, Path]], List[Tuple[Path, Path]]]:
        """
        Auto-discover symlinks and overlays by scanning private repo.

        Returns:
            (symlinks, overlays) where each is a list of (source, dest) tuples
        """
        symlinks = []
        overlays = []

        # Scan all files in private repo (excluding backups dir)
        for root, dirs, files in os.walk(self.private_repo):
            # Skip the backups directory for symlink discovery
            if Path(root).name == "backups" or "backups" in Path(root).parts:
                continue

            # Skip .git directories - they shouldn't be managed by dotman
            if ".git" in Path(root).parts:
                continue

            root_path = Path(root)
            for file in files:
                source = root_path / file

                # Calculate relative path from private repo root
                rel_path = source.relative_to(self.private_repo)
                dest = self.working_dir / rel_path

                # Decide symlink vs overlay based on .gitignore
                if self.gitignore_checker.is_ignored(str(rel_path)):
                    symlinks.append((source, dest))
                else:
                    # Auto-create backup if it doesn't exist
                    backup_path = self.backups_dir / rel_path
                    if not backup_path.exists():
                        # Create backup directory structure
                        backup_path.parent.mkdir(parents=True, exist_ok=True)
                        # Copy the original file to backup
                        shutil.copy2(source, backup_path)
                        print(f"✓ Auto-created backup: {rel_path}")
                    overlays.append((backup_path, dest))

        # Also scan backups directory for additional overlays
        if self.backups_dir.exists():
            for root, dirs, files in os.walk(self.backups_dir):
                root_path = Path(root)
                for file in files:
                    backup_source = root_path / file
                    rel_path = backup_source.relative_to(self.backups_dir)
                    dest = self.working_dir / rel_path

                    # Only add if not already in overlays
                    if (backup_source, dest) not in overlays:
                        overlays.append((backup_source, dest))

        return symlinks, overlays

    def get_skip_worktree_files(self) -> Set[str]:
        """Get list of files currently marked with --skip-worktree."""
        try:
            os.chdir(self.working_dir)
            result = subprocess.run(['git', 'ls-files', '-v'],
                                  capture_output=True, text=True, check=True)
            skip_files = set()
            for line in result.stdout.splitlines():
                if line.startswith('S '):  # S indicates skip-worktree
                    skip_files.add(line[2:])  # Remove 'S ' prefix
            return skip_files
        except subprocess.CalledProcessError:
            return set()

    def is_file_tracked_by_git(self, file_path: Path) -> bool:
        """Check if a file is tracked by git."""
        try:
            os.chdir(self.working_dir)
            rel_path = file_path.relative_to(self.working_dir)
            result = subprocess.run(['git', 'ls-files', str(rel_path)],
                                  capture_output=True, text=True)
            return bool(result.stdout.strip())
        except Exception:
            return False

    def setup_symlinks(self, symlinks: List[Tuple[Path, Path]]) -> None:
        """Create symlinks for private files."""
        print("=== Setting up symlinks for private files ===")

        for source, dest in symlinks:
            # Create parent directory if needed
            dest.parent.mkdir(parents=True, exist_ok=True)

            # Check if symlink already exists and is correct
            if dest.is_symlink() and dest.resolve() == source.resolve():
                print(f"✓ {dest.relative_to(self.working_dir)} -> already linked")
                continue

            # Remove existing file/symlink if present
            if dest.exists() or dest.is_symlink():
                if dest.is_symlink():
                    dest.unlink()
                    print(f"⚠ Removed incorrect symlink: {dest.relative_to(self.working_dir)}")
                else:
                    print(f"⚠ File exists, skipping: {dest.relative_to(self.working_dir)}")
                    continue

            # Create the symlink
            if source.exists():
                dest.symlink_to(source)
                print(f"✓ Created {dest.relative_to(self.working_dir)} -> {source.name}")
            else:
                print(f"✗ Source missing: {source}")

    def apply_overlays(self, overlays: List[Tuple[Path, Path]]) -> None:
        """Apply overlay files and manage skip-worktree."""
        print("\n=== Applying local modifications ===")

        os.chdir(self.working_dir)
        current_skip_files = self.get_skip_worktree_files()

        for source, dest in overlays:
            if not source.exists():
                print(f"✗ Backup not found: {source}")
                continue

            # Create parent directory if needed
            dest.parent.mkdir(parents=True, exist_ok=True)

            # Copy the overlay file
            shutil.copy2(source, dest)
            rel_dest = str(dest.relative_to(self.working_dir))

            # Manage skip-worktree if file is tracked by git
            if self.is_file_tracked_by_git(dest):
                if rel_dest not in current_skip_files:
                    try:
                        subprocess.run(['git', 'update-index', '--skip-worktree', rel_dest],
                                     check=True, capture_output=True)
                        print(f"✓ Applied overlay + skip-worktree: {rel_dest}")
                    except subprocess.CalledProcessError:
                        print(f"⚠ Applied overlay but skip-worktree failed: {rel_dest}")
                else:
                    print(f"✓ Applied overlay: {rel_dest}")
            else:
                print(f"✓ Applied overlay (untracked): {rel_dest}")

    def status(self) -> None:
        """Show current status of symlinks and overlays."""
        symlinks, overlays = self.discover_files()
        skip_files = self.get_skip_worktree_files()

        print("=== Dotfiles Status ===")

        print("\nPrivate Files (Symlinks):")
        for source, dest in symlinks:
            rel_dest = dest.relative_to(self.working_dir)
            if dest.is_symlink() and dest.resolve() == source.resolve():
                status = "✓ linked"
            elif dest.exists():
                status = "⚠ file exists (not symlinked)"
            else:
                status = "✗ missing"
            print(f"  {rel_dest} -> {status}")

        print("\nLocal Modifications (Overlays):")
        for source, dest in overlays:
            rel_dest = str(dest.relative_to(self.working_dir))
            if dest.exists():
                if rel_dest in skip_files:
                    status = "✓ applied + protected"
                elif self.is_file_tracked_by_git(dest):
                    status = "⚠ applied but not protected"
                else:
                    status = "✓ applied (untracked)"
            else:
                status = "✗ not applied"
            print(f"  {rel_dest} -> {status}")

        # Show any extra skip-worktree files
        overlay_files = {str(dest.relative_to(self.working_dir)) for _, dest in overlays}
        extra_skip = skip_files - overlay_files
        if extra_skip:
            print("\nOther Skip-Worktree Files:")
            for f in sorted(extra_skip):
                print(f"  {f} -> ⚠ skip-worktree but no backup")

    def diff(self) -> None:
        """Show diffs for overlay files."""
        _, overlays = self.discover_files()
        skip_files = self.get_skip_worktree_files()

        print("=== Local Modifications Diff ===")
        os.chdir(self.working_dir)

        # Temporarily unmark skip-worktree files to see diffs
        files_to_remark = []
        for _, dest in overlays:
            rel_dest = str(dest.relative_to(self.working_dir))
            if rel_dest in skip_files:
                try:
                    subprocess.run(['git', 'update-index', '--no-skip-worktree', rel_dest],
                                 check=True, capture_output=True)
                    files_to_remark.append(rel_dest)
                except subprocess.CalledProcessError:
                    pass

        # Show the diff
        try:
            subprocess.run(['git', 'diff'] + files_to_remark, check=False)
        except Exception:
            pass

        # Re-mark files
        for f in files_to_remark:
            try:
                subprocess.run(['git', 'update-index', '--skip-worktree', f],
                             check=True, capture_output=True)
            except subprocess.CalledProcessError:
                pass

    def clean(self, force: bool = False) -> None:
        """Remove all dotman modifications - revert git changes and delete symlinks."""
        symlinks, overlays = self.discover_files()
        skip_files = self.get_skip_worktree_files()

        print("=== Removing all dotman modifications ===")

        # Show what will be removed
        symlink_count = len(symlinks)
        overlay_count = len([dest for _, dest in overlays if dest.exists()])
        skip_count = len(skip_files)

        print("This will:")
        if symlink_count > 0:
            print(f"  • Remove {symlink_count} symlink(s)")
        if overlay_count > 0:
            print(f"  • Revert {overlay_count} local modification(s)")
        if skip_count > 0:
            print(f"  • Clear {skip_count} skip-worktree flag(s)")

        if symlink_count == 0 and overlay_count == 0 and skip_count == 0:
            print("Nothing to remove - no dotman modifications found.")
            return

        # Confirm unless --force is used
        if not force:
            response = input("\nContinue? [y/N]: ").strip().lower()
            if response not in ['y', 'yes']:
                print("Operation cancelled.")
                return

        print()
        os.chdir(self.working_dir)

        # 1. Remove symlinks
        removed_symlinks = 0
        for source, dest in symlinks:
            if dest.is_symlink():
                dest.unlink()
                print(f"✓ Removed symlink: {dest.relative_to(self.working_dir)}")
                removed_symlinks += 1
            elif dest.exists():
                print(f"⚠ Skipped non-symlink file: {dest.relative_to(self.working_dir)}")

        # 2. Revert overlay files and clear skip-worktree
        reverted_files = []
        for _, dest in overlays:
            if not dest.exists():
                continue

            rel_dest = str(dest.relative_to(self.working_dir))

            # Clear skip-worktree if set
            if rel_dest in skip_files:
                try:
                    subprocess.run(['git', 'update-index', '--no-skip-worktree', rel_dest],
                                 check=True, capture_output=True)
                except subprocess.CalledProcessError:
                    pass

            # Revert to HEAD if tracked by git
            if self.is_file_tracked_by_git(dest):
                try:
                    subprocess.run(['git', 'checkout', 'HEAD', '--', rel_dest],
                                 check=True, capture_output=True)
                    reverted_files.append(rel_dest)
                    print(f"✓ Reverted: {rel_dest}")
                except subprocess.CalledProcessError:
                    print(f"⚠ Could not revert: {rel_dest}")
            else:
                # For untracked files, just remove them
                try:
                    dest.unlink()
                    print(f"✓ Removed untracked file: {rel_dest}")
                except Exception:
                    print(f"⚠ Could not remove: {rel_dest}")

        # 3. Clear any remaining skip-worktree flags
        remaining_skip = skip_files - {str(dest.relative_to(self.working_dir)) for _, dest in overlays}
        for f in remaining_skip:
            try:
                subprocess.run(['git', 'update-index', '--no-skip-worktree', f],
                             check=True, capture_output=True)
                print(f"✓ Cleared skip-worktree: {f}")
            except subprocess.CalledProcessError:
                pass

        print("\n✓ Removal complete!")
        print(f"  • Removed {removed_symlinks} symlink(s)")
        print(f"  • Reverted {len(reverted_files)} file(s)")
        print(f"  • Cleared {len(skip_files)} skip-worktree flag(s)")

    def dirty(self) -> None:
        """Full setup - create symlinks and apply overlays."""
        symlinks, overlays = self.discover_files()
        self.setup_symlinks(symlinks)
        self.apply_overlays(overlays)
        print("\n✓ Setup complete!")

def main():
    # Both -h and --help now use the same formatter with full documentation
    parser = argparse.ArgumentParser(
        description="Manage dotfiles and local modifications",
        formatter_class=DotmanLongHelpFormatter
    )

    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Dirty command
    subparsers.add_parser('dirty', help='Create symlinks and apply overlays')

    # Status command
    subparsers.add_parser('status', help='Show current status')

    # Diff command
    subparsers.add_parser('diff', help='Show diffs for local modifications')

    # Clean command
    clean_parser = subparsers.add_parser('clean', help='Remove all dotman modifications (revert git changes and delete symlinks)')
    clean_parser.add_argument('--force', action='store_true',
                              help='Skip confirmation prompt')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    manager = DotfilesManager()

    if args.command == 'dirty':
        manager.dirty()
    elif args.command == 'status':
        manager.status()
    elif args.command == 'diff':
        manager.diff()
    elif args.command == 'clean':
        manager.clean(force=args.force)

if __name__ == "__main__":
    main()